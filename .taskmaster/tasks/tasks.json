{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup TTS Enhancement Project Structure",
        "description": "Initialize project structure and dependencies for Voice Command Results TTS Enhancement",
        "details": "Create the foundational project structure for the TTS enhancement. Install required dependencies using UV package manager: elevenlabs==1.16.0, python-dotenv==1.0.1. Create directory structure: .claude/hooks/post-tool-use/ for the enhanced hook, .claude/lib/tts/ for TTS utilities. Initialize configuration schema in .claude/settings.json with default tts_settings object. Ensure Python 3.8+ compatibility and cross-platform support (macOS, Linux, Windows).",
        "testStrategy": "Verify project structure creation, confirm all dependencies install correctly with UV, validate that .claude/settings.json accepts new tts_settings schema without breaking existing configurations. Test cross-platform compatibility by running setup on different OS environments.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Core Text Processing Module",
        "description": "Create intelligent text extraction and word counting functionality for tool responses",
        "details": "Develop text_processor.py module in .claude/lib/tts/. Implement extract_text_from_response() function to handle various tool response formats (string, dict, list). Create accurate word_count() function using regex pattern r'\\S+' to handle multiline content, special characters, and whitespace. Add strip_ansi_codes() to clean terminal output. Implement is_concise_output() to check if text meets word count threshold. Handle edge cases: empty responses, binary data, malformed JSON.",
        "testStrategy": "Unit test word counting with various inputs: single line, multiline, special characters, ANSI codes, Unicode. Test extraction from different response types. Verify accuracy against manual word counts. Test performance with large text blocks.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement text extraction function for various response types",
            "description": "Create extract_text_from_response() function to handle string, dict, and list response formats",
            "dependencies": [],
            "details": "Develop the core extraction logic in text_processor.py that can intelligently extract text content from different response types. Handle string responses directly, extract values from dictionary responses (checking for common keys like 'content', 'text', 'message', 'output'), and concatenate list items. Include type checking and safe extraction with fallbacks.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement word counting with regex pattern",
            "description": "Create word_count() function using regex pattern r'\\S+' for accurate counting",
            "dependencies": [],
            "details": "Implement the word counting function using the regex pattern r'\\S+' to match sequences of non-whitespace characters. This approach correctly handles multiline content, special characters, punctuation, and various whitespace types. The function should return an integer count of words found in the input text.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create ANSI code stripping functionality",
            "description": "Implement strip_ansi_codes() function to clean terminal output",
            "dependencies": [],
            "details": "Develop a function that removes ANSI escape sequences from text using regex pattern matching. The pattern should match sequences like \\x1b[...m for colors and formatting, as well as other ANSI control sequences. This ensures clean text for both word counting and TTS processing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement concise output checking logic",
            "description": "Create is_concise_output() function to check word count thresholds",
            "dependencies": [
              2
            ],
            "details": "Build a function that uses the word_count() function to determine if text meets the configured word count threshold (default 20 words). The function should accept the text and threshold as parameters, returning a boolean. Include logic to handle empty text and ensure ANSI codes are stripped before counting.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement edge case handling",
            "description": "Add robust error handling for empty responses, binary data, and malformed JSON",
            "dependencies": [
              1,
              3
            ],
            "details": "Enhance the text extraction and processing functions with comprehensive edge case handling. Handle None/empty responses gracefully, detect and skip binary data (check for non-printable characters), handle malformed JSON with try-except blocks, and ensure all functions return appropriate defaults when encountering errors.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create comprehensive unit test suite",
            "description": "Develop unit tests for all text processing functions with various input scenarios",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create test_text_processor.py with comprehensive test coverage. Test word counting with single line, multiline, special characters, ANSI codes, Unicode text, and empty strings. Test text extraction from strings, dictionaries with various key structures, lists, and malformed data. Verify ANSI stripping works correctly. Test performance with large text blocks (>10KB). Include edge case tests for binary data and None values.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Tool-Specific Content Filters",
        "description": "Implement intelligent filtering logic for different tool types and their outputs",
        "details": "Create tool_filters.py with ToolFilter class hierarchy. Implement base filter with should_speak() method. Create specific filters: BashFilter (check exit codes, speak confirmations), GitFilter (status updates, commit confirmations), FileOperationFilter (Read, Write confirmations), SearchFilter (Grep/LS result counts). Default exclusion list: ['Read', 'Grep', 'LS']. Add custom message generation for specific tool outputs (e.g., 'Command completed successfully' for exit code 0).",
        "testStrategy": "Test each filter with representative tool outputs. Verify Bash commands speak exit codes appropriately. Test Git operations return concise status messages. Ensure file operations provide appropriate confirmations. Validate search tools are properly excluded.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement base ToolFilter abstract class",
            "description": "Create the foundational ToolFilter abstract base class with core filtering interface",
            "dependencies": [],
            "details": "Create tool_filters.py module. Design ToolFilter ABC with methods: should_speak(tool_name, response_data) -> bool, get_custom_message(tool_name, response_data) -> Optional[str], get_tool_name() -> str. Include common utility methods for response parsing and default behavior. Add type hints and comprehensive docstrings.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement BashFilter with exit code handling",
            "description": "Create BashFilter class that handles Bash command outputs and exit codes",
            "dependencies": [
              1
            ],
            "details": "Inherit from ToolFilter. Parse Bash response to extract exit_code field. Implement logic: speak if exit_code != 0, generate custom error messages based on exit codes (e.g., 'Command failed with error code X'). For exit_code == 0, return 'Command completed successfully' only for significant commands. Filter out common silent commands like 'cd', 'export', etc.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create GitFilter for version control operations",
            "description": "Implement GitFilter to handle Git command outputs with concise status messages",
            "dependencies": [
              1
            ],
            "details": "Detect Git operations from command patterns (commit, push, pull, status). Generate concise messages: 'Changes committed successfully', 'Pushed to remote', 'Repository updated'. Parse Git output for relevant information (branch names, file counts). Suppress verbose Git output while preserving important status updates.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build FileOperationFilter for Read/Write operations",
            "description": "Implement filter for file operation tools with appropriate confirmations",
            "dependencies": [
              1
            ],
            "details": "Handle Read, Write, Edit, MultiEdit tools. For Write/Edit operations, generate confirmations like 'File updated: [filename]'. For Read operations, return None (exclude from TTS) unless file not found. Extract filenames from tool parameters. Handle error cases with appropriate messages.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Develop SearchFilter for Grep and LS tools",
            "description": "Create filter to handle search tool outputs with result count summaries",
            "dependencies": [
              1
            ],
            "details": "Filter Grep and LS tools by default (return False from should_speak). Option to enable with result summaries: 'Found X matches in Y files' for Grep, 'Directory contains X items' for LS. Parse search results to extract counts. Handle empty results appropriately.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement default exclusion list management",
            "description": "Create configurable default exclusion list for tools that shouldn't trigger TTS",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implement DEFAULT_EXCLUDED_TOOLS = ['Read', 'Grep', 'LS', 'TodoRead']. Add configuration loading from settings to override defaults. Create ToolFilterRegistry to manage all filters and exclusions. Implement get_filter(tool_name) method to return appropriate filter instance. Add method to check if tool is excluded before applying filters.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create custom message generation system",
            "description": "Build flexible message templating for tool-specific outputs",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implement MessageTemplate class with placeholders for tool output values. Create message templates for each filter type. Support variable extraction from tool responses (filenames, counts, status codes). Add message length optimization for TTS. Implement fallback to raw output if custom message generation fails.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Build ElevenLabs TTS Integration Layer",
        "description": "Create robust integration with ElevenLabs API for voice synthesis",
        "details": "Develop elevenlabs_client.py wrapper using elevenlabs Python SDK. Implement TTSClient class with methods: speak_text(text, voice_id), validate_api_key(), get_available_voices(). Add connection pooling and request queuing. Implement retry logic with exponential backoff for API failures. Support voice IDs: David (6sFKzaJr574YWVu4UuJF), Cornelius (qPTgKs2gqb0Fq4SoX4yT), Britney (EuMDy7VrNalBMQBXZkJO). Handle rate limiting gracefully with queue management.",
        "testStrategy": "Mock ElevenLabs API for unit tests. Test API key validation, voice selection, and text synthesis. Verify retry logic with simulated failures. Test rate limiting behavior. Validate audio playback on different platforms.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TTSClient class architecture and interface",
            "description": "Create the base TTSClient class structure with method signatures and properties",
            "dependencies": [],
            "details": "Define TTSClient class in elevenlabs_client.py with core methods: __init__, speak_text(text, voice_id), validate_api_key(), get_available_voices(). Add properties for api_key, base_url, timeout settings. Design abstract interface for future extensibility. Include type hints and docstrings for all methods.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement API authentication and key validation",
            "description": "Build secure API key handling and validation mechanisms",
            "dependencies": [
              1
            ],
            "details": "Implement validate_api_key() method using ElevenLabs SDK. Add secure API key storage from environment variables or config. Create authentication error handling with specific error codes. Implement API key rotation support. Add validation caching to reduce API calls.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build voice selection and management system",
            "description": "Implement voice ID handling and voice listing functionality",
            "dependencies": [
              1,
              2
            ],
            "details": "Create get_available_voices() method returning voice metadata. Implement voice_id validation against supported IDs: David (6sFKzaJr574YWVu4UuJF), Cornelius (qPTgKs2gqb0Fq4SoX4yT), Britney (EuMDy7VrNalBMQBXZkJO). Add voice caching mechanism. Build voice fallback logic if preferred voice unavailable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop connection pooling and session management",
            "description": "Create efficient connection pooling for API requests",
            "dependencies": [
              2
            ],
            "details": "Implement connection pool using urllib3 or aiohttp. Configure pool size, connection timeout, and keep-alive settings. Add connection health checks and automatic reconnection. Implement session reuse for multiple requests. Add metrics for pool utilization.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement retry logic with exponential backoff",
            "description": "Build robust retry mechanism for handling API failures",
            "dependencies": [
              4
            ],
            "details": "Create retry decorator with exponential backoff algorithm. Configure max retries (default 3), initial delay (1s), max delay (30s), backoff factor (2). Handle specific error types: network errors, rate limits, server errors. Add jitter to prevent thundering herd. Log retry attempts with reason.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create rate limiting and request queue system",
            "description": "Implement intelligent rate limiting to respect API quotas",
            "dependencies": [
              4,
              5
            ],
            "details": "Build TokenBucket rate limiter for API calls. Implement request queue with priority support. Add queue overflow handling strategies. Create rate limit headers parsing (X-RateLimit-*). Implement adaptive rate limiting based on API responses. Add queue persistence for crash recovery.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Build cross-platform audio playback module",
            "description": "Implement audio playback that works across different operating systems",
            "dependencies": [
              1
            ],
            "details": "Create AudioPlayer class with platform detection. Implement macOS playback using afplay or PyObjC. Add Windows support using winsound or pygame. Include Linux support via aplay or pulse audio. Handle audio format conversion if needed. Add volume control and playback interruption handling.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement comprehensive error handling system",
            "description": "Create robust error handling for all API failure scenarios",
            "dependencies": [
              5,
              6,
              7
            ],
            "details": "Define custom exception hierarchy: TTSError, AuthenticationError, RateLimitError, VoiceNotFoundError, PlaybackError. Implement graceful degradation strategies. Add error recovery mechanisms. Create user-friendly error messages. Log errors with full context for debugging. Add error metrics collection.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Configuration Management System",
        "description": "Create comprehensive configuration system for TTS settings integration",
        "details": "Build config_manager.py to handle .claude/settings.json integration. Implement TTSConfig class with properties: enabled (bool), max_words (int, default 20), voice_id (string), skip_tools (list), speak_confirmations (bool), volume (float 0-1), speed (float 0.5-2.0). Add validation methods for each setting. Implement hot-reload capability for runtime updates. Create merge_with_defaults() for backward compatibility. Add schema migration for existing configs.",
        "testStrategy": "Test configuration loading, validation, and merging with defaults. Verify hot-reload functionality. Test invalid configuration handling. Ensure backward compatibility with existing settings.json files. Test schema migration scenarios.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TTSConfig class with property definitions",
            "description": "Implement the core TTSConfig class with all required properties and type annotations",
            "dependencies": [],
            "details": "Create TTSConfig class in config_manager.py with properties: enabled (bool), max_words (int, default 20), voice_id (string), skip_tools (list), speak_confirmations (bool), volume (float 0-1), speed (float 0.5-2.0). Use dataclass or regular class with proper initialization. Include type hints and default values for all properties.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement configuration validation methods",
            "description": "Add validation logic for each configuration property with appropriate error handling",
            "dependencies": [
              1
            ],
            "details": "Create validation methods for each property: validate_volume() (0-1 range), validate_speed() (0.5-2.0 range), validate_voice_id() (non-empty string), validate_skip_tools() (list of strings), validate_max_words() (positive integer). Implement validate_all() method that runs all validators. Return validation errors with clear messages.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build settings.json integration logic",
            "description": "Create functions to load and save TTS configuration from/to .claude/settings.json",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement load_from_settings() to read .claude/settings.json and extract TTS configuration section. Create save_to_settings() to update settings.json while preserving other configurations. Handle missing TTS section gracefully. Use json library with proper indentation and formatting. Implement file locking for concurrent access safety.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement hot-reload functionality",
            "description": "Add file watching and automatic configuration reload capabilities",
            "dependencies": [
              3
            ],
            "details": "Use watchdog library or polling mechanism to monitor .claude/settings.json changes. Implement reload_config() method that validates and applies new configuration without restart. Create configuration change callbacks to notify dependent components. Add debouncing to prevent rapid reloads. Handle file access errors during reload gracefully.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create default merging and backward compatibility logic",
            "description": "Implement merge_with_defaults() and ensure backward compatibility with existing configs",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create merge_with_defaults() method that combines user settings with default values. Handle missing properties by applying defaults. Preserve user settings while filling gaps. Implement version detection for older settings.json formats. Create compatibility layer for deprecated property names. Ensure smooth upgrade path for existing users.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement schema migration system",
            "description": "Build migration framework to upgrade configuration schemas between versions",
            "dependencies": [
              5
            ],
            "details": "Create migration registry with version tracking. Implement migrate_v1_to_v2() style functions for each schema change. Add schema version property to configuration. Create backup of original settings before migration. Implement rollback capability if migration fails. Log migration steps for debugging. Test with various legacy configuration formats.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop Asynchronous TTS Execution Engine",
        "description": "Create non-blocking TTS execution system for optimal performance",
        "details": "Implement async_tts_engine.py using asyncio for non-blocking execution. Create TTSQueue class with max 3 concurrent requests. Implement speak_async(text, config) method returning immediately. Add queue management with priority handling for recent commands. Implement resource cleanup and memory management. Create background worker thread for TTS processing. Add graceful shutdown handling.",
        "testStrategy": "Test concurrent TTS requests don't block command execution. Measure command execution time with/without TTS. Verify queue limits are enforced. Test resource cleanup and memory usage. Validate graceful shutdown scenarios.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Async Architecture with asyncio",
            "description": "Create the foundational asynchronous architecture design using asyncio for non-blocking TTS operations",
            "dependencies": [],
            "details": "Design the overall async architecture pattern. Define interfaces for async components. Create base async context managers. Establish event loop management strategy. Design coroutine patterns for TTS operations. Document architectural decisions and patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement TTSQueue Class with Concurrency Control",
            "description": "Build the core TTSQueue class that manages concurrent TTS requests with a maximum of 3 simultaneous operations",
            "dependencies": [
              1
            ],
            "details": "Create TTSQueue class in async_tts_engine.py. Implement semaphore-based concurrency limiting (max 3). Add queue data structure for pending requests. Implement enqueue/dequeue methods. Add queue size monitoring. Create queue overflow handling strategy.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Priority Queue Management System",
            "description": "Implement priority-based queue management to handle recent commands with higher priority",
            "dependencies": [
              2
            ],
            "details": "Extend TTSQueue with priority queue using heapq. Implement priority calculation based on request timestamp. Add priority boost for recent commands (<2 seconds). Create queue reordering logic. Implement starvation prevention for low-priority items. Add priority metrics tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Background Worker Thread Infrastructure",
            "description": "Set up background worker threads for processing TTS requests without blocking the main execution",
            "dependencies": [
              1,
              2
            ],
            "details": "Create ThreadPoolExecutor for TTS workers. Implement worker thread lifecycle management. Create thread-safe communication between main and worker threads. Implement work distribution algorithm. Add thread health monitoring. Create thread restart mechanism for failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Resource Cleanup Mechanisms",
            "description": "Build comprehensive resource cleanup systems to prevent memory leaks and resource exhaustion",
            "dependencies": [
              2,
              4
            ],
            "details": "Implement context managers for automatic resource cleanup. Create cleanup handlers for audio streams and API connections. Add periodic cleanup tasks for stale requests. Implement memory usage monitoring. Create resource leak detection. Add cleanup scheduling and triggers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Develop Memory Management Implementation",
            "description": "Create memory management system to optimize TTS operations and prevent memory issues",
            "dependencies": [
              5
            ],
            "details": "Implement audio buffer management with size limits. Create LRU cache for frequently used TTS results. Add memory usage profiling and limits. Implement garbage collection optimization. Create memory pressure response mechanisms. Add OOM prevention strategies.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Build Graceful Shutdown Handling",
            "description": "Implement graceful shutdown mechanisms to ensure clean termination of all TTS operations",
            "dependencies": [
              4,
              5
            ],
            "details": "Create shutdown signal handlers (SIGTERM, SIGINT). Implement request draining during shutdown. Add timeout-based forced shutdown. Create state persistence for in-flight requests. Implement cleanup sequence ordering. Add shutdown status reporting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Integrate Performance Monitoring System",
            "description": "Add comprehensive performance monitoring to track and optimize TTS execution",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement execution time tracking for each TTS request. Create queue depth and latency metrics. Add concurrent request monitoring. Implement performance bottleneck detection. Create performance dashboards/logs. Add alerting for performance degradation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Ensure Thread-Safe Operation Guarantees",
            "description": "Implement and verify thread-safety across all TTS engine components",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Add thread-safe locks for shared resources. Implement atomic operations for critical sections. Create thread-safe logging mechanisms. Add race condition detection and prevention. Implement deadlock prevention strategies. Create comprehensive thread-safety test suite.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Create Enhanced PostToolUse Hook",
        "description": "Modify existing PostToolUse hook to integrate TTS functionality",
        "details": "Enhance existing post_tool_use.py hook to add TTS processing. Preserve all existing logging functionality. Add TTS trigger logic: check if tool in skip_tools, extract text from response, check word count, apply tool-specific filters, queue for TTS if eligible. Implement error boundaries to prevent TTS failures from affecting hook execution. Add performance monitoring to ensure <100ms overhead.",
        "testStrategy": "Test hook with various tool responses. Verify existing logging is preserved. Measure performance overhead. Test error scenarios don't break hook execution. Validate TTS triggering logic across all tool types.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Existing PostToolUse Hook Structure",
            "description": "Review and understand the current post_tool_use.py implementation to identify integration points",
            "dependencies": [],
            "details": "Examine existing logging functionality, hook structure, and execution flow. Document current functionality that must be preserved. Identify optimal insertion points for TTS logic without disrupting existing operations. Map out the hook's data flow and processing pipeline.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Import Required Dependencies and Components",
            "description": "Add imports for TTS components, tool filters, and performance monitoring utilities",
            "dependencies": [
              1
            ],
            "details": "Import ToolFilter classes from tool_filters.py, TTSQueue from tts_queue.py, text extraction utilities, and performance timing modules. Ensure all imports are properly organized and follow project conventions. Add conditional imports for components that may not be available.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement TTS Configuration Loading",
            "description": "Add configuration loading for TTS settings including skip lists and thresholds",
            "dependencies": [
              2
            ],
            "details": "Load skip_tools list from configuration, word count thresholds, and TTS enabled/disabled state. Implement configuration validation and default values. Cache configuration to avoid repeated file reads. Handle missing configuration gracefully.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create TTS Trigger Decision Logic",
            "description": "Implement the core logic to determine if a tool response should trigger TTS",
            "dependencies": [
              3
            ],
            "details": "Check if tool is in skip_tools list, verify TTS is enabled globally, validate response has extractable text content. Implement early exit conditions for performance. Create clear decision flow with logging for debugging.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Text Extraction and Processing",
            "description": "Extract and process text content from various tool response formats",
            "dependencies": [
              4
            ],
            "details": "Handle different response structures (strings, objects, arrays). Strip formatting, escape sequences, and control characters. Normalize whitespace and handle encoding issues. Extract meaningful content from complex responses.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Word Count Verification and Filtering",
            "description": "Implement word count checking and apply tool-specific filters",
            "dependencies": [
              5
            ],
            "details": "Count words in extracted text, compare against configured thresholds. Instantiate appropriate ToolFilter based on tool type. Apply filter's should_speak() logic and custom message generation. Handle filter exceptions gracefully.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate TTS Queue and Error Handling",
            "description": "Queue approved text for TTS and implement comprehensive error boundaries",
            "dependencies": [
              6
            ],
            "details": "Call TTSQueue.add_to_queue() for approved text. Wrap all TTS logic in try-except blocks to prevent hook failure. Log TTS errors without interrupting hook execution. Implement timeout handling for TTS operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Add Performance Monitoring and Optimization",
            "description": "Implement performance tracking to ensure <100ms overhead requirement",
            "dependencies": [
              7
            ],
            "details": "Add timing measurements around TTS logic. Implement performance logging for analysis. Optimize hot paths and add caching where beneficial. Create performance alerts if overhead exceeds threshold. Add option to disable TTS in performance-critical scenarios.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Error Handling and Fallback System",
        "description": "Create comprehensive error handling with graceful degradation",
        "details": "Build error_handler.py with TTSErrorHandler class. Implement handling for: API key issues (clear user message), network failures (silent fallback), audio device unavailable (log and continue), invalid configuration (use defaults). Add fallback to system TTS using platform-specific APIs (macOS: NSSpeechSynthesizer, Windows: SAPI, Linux: espeak). Implement circuit breaker pattern for API failures. Create error recovery strategies.",
        "testStrategy": "Test each error scenario with appropriate simulation. Verify fallback mechanisms work on each platform. Test circuit breaker behavior. Ensure errors don't interrupt workflow. Validate error messages are helpful.",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TTSErrorHandler class structure",
            "description": "Create base error handling class with comprehensive error categorization",
            "dependencies": [],
            "details": "Build error_handler.py with TTSErrorHandler base class. Define error categories: APIError, NetworkError, AudioError, ConfigError, PlatformError. Implement error severity levels (critical, warning, info). Create error context preservation for debugging. Add error logging with structured format. Design error state tracking for circuit breaker implementation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement API key error handling",
            "description": "Handle missing, invalid, or rate-limited API key scenarios",
            "dependencies": [
              1
            ],
            "details": "Create APIKeyErrorHandler extending TTSErrorHandler. Detect missing API keys in environment/config. Handle 401/403 authentication errors from ElevenLabs. Implement rate limit detection (429 status). Create user-friendly error messages: 'TTS API key not configured. Please add ELEVENLABS_API_KEY to your environment.' Add API key validation on startup.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build network failure recovery system",
            "description": "Implement robust handling for network connectivity issues",
            "dependencies": [
              1
            ],
            "details": "Create NetworkErrorHandler with timeout detection, connection refused handling, DNS resolution failures. Implement exponential backoff retry logic (max 3 attempts). Add network status monitoring. Create offline mode detection. Implement request queuing for temporary failures. Add connection pooling for efficiency.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop audio device error handling",
            "description": "Handle audio playback failures and device unavailability",
            "dependencies": [
              1
            ],
            "details": "Create AudioDeviceErrorHandler for device detection failures, playback errors, audio format incompatibilities. Implement device enumeration and selection. Handle pygame mixer initialization errors. Add fallback to alternative audio libraries (simpleaudio, pyaudio). Create audio device health checks. Log audio errors without interrupting workflow.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement platform-specific TTS fallbacks",
            "description": "Create native TTS fallback for each major platform",
            "dependencies": [
              1,
              4
            ],
            "details": "Build PlatformTTSFallback with OS detection. macOS: implement NSSpeechSynthesizer via PyObjC or subprocess 'say' command. Windows: use win32com.client for SAPI or subprocess 'powershell Add-Type'. Linux: integrate espeak or festival via subprocess. Create unified interface for all platforms. Handle platform detection failures gracefully.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement circuit breaker pattern",
            "description": "Create circuit breaker for API failure protection",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Build CircuitBreaker class with states: closed (normal), open (failing), half-open (testing). Configure thresholds: 5 failures opens circuit, 30 second timeout, 1 success closes. Track failure counts and timestamps. Implement state transitions with logging. Create reset mechanisms. Add metrics collection for monitoring. Integrate with all API calls.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Design error recovery strategies",
            "description": "Create intelligent recovery mechanisms for different error types",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Implement RecoveryStrategy pattern with specific strategies: API errors -> fallback to platform TTS, Network errors -> queue and retry with backoff, Audio errors -> switch output device or use system bells, Config errors -> use safe defaults. Create strategy selection logic based on error type and history. Add recovery success tracking. Implement graceful degradation chain.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Build user notification system",
            "description": "Create non-intrusive error notification for users",
            "dependencies": [
              1,
              7
            ],
            "details": "Design ErrorNotifier with minimal disruption principle. Implement notification channels: log file (.claude/logs/tts_errors.log), single-line stderr messages for critical errors, system notification for persistent failures (optional). Create error message formatting for clarity. Add error suppression for repeated errors. Implement daily error summary. Ensure errors never interrupt main workflow.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Build Performance Monitoring and Optimization",
        "description": "Implement performance tracking and optimization mechanisms",
        "details": "Create performance_monitor.py with metrics collection: TTS response time, queue length, API call count, memory usage. Implement intelligent caching for repeated messages. Add request deduplication for identical texts within 5 seconds. Create performance report generation. Optimize text processing with compiled regex patterns. Implement lazy loading for TTS components.",
        "testStrategy": "Benchmark TTS operations under load. Test caching effectiveness. Verify deduplication works correctly. Measure memory usage patterns. Validate performance metrics accuracy.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design metrics collection framework architecture",
            "description": "Create the overall architecture for performance metrics collection including data structures, storage mechanisms, and collection interfaces",
            "dependencies": [],
            "details": "Design PerformanceMonitor base class with methods for registering metrics collectors. Define metric types: counters, gauges, histograms, timers. Create MetricData dataclass with fields: name, value, timestamp, metadata. Design thread-safe metric storage using collections.deque for time-series data. Plan metric aggregation strategies (avg, min, max, p95, p99). Define metric namespaces for different components (tts, api, cache, memory).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement response time tracking system",
            "description": "Build comprehensive response time measurement for TTS operations and API calls",
            "dependencies": [
              1
            ],
            "details": "Create ResponseTimeTracker class with context managers for timing operations. Implement @timed decorator for automatic method timing. Track: TTS processing time (text prep to audio ready), API call latency (request to response), queue wait time, audio playback duration. Store timing data in circular buffer (last 1000 operations). Calculate rolling averages and percentiles. Add breakdown by operation type and voice ID.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create memory usage monitoring module",
            "description": "Implement memory tracking and analysis for identifying leaks and optimization opportunities",
            "dependencies": [
              1
            ],
            "details": "Build MemoryMonitor using psutil for process memory tracking. Monitor: RSS, VMS, shared memory, Python heap usage via gc module. Track memory growth over time with snapshots every 30 seconds. Implement object reference counting for major components. Add memory profiling decorators for high-risk functions. Create alerts for memory usage exceeding thresholds (>50MB growth). Include garbage collection statistics.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build intelligent message caching system",
            "description": "Implement smart caching for TTS responses to reduce API calls and improve response times",
            "dependencies": [
              1
            ],
            "details": "Create TTSCache class with LRU eviction policy (max 100 entries). Use hash of (text, voice_id, settings) as cache key. Store audio data in memory with optional disk spillover. Implement cache warming for common phrases. Add cache hit/miss ratio tracking. Support cache invalidation by age (24 hours) or manual clear. Include compression for cached audio (gzip). Estimate and track cache memory usage.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement request deduplication logic",
            "description": "Build deduplication system to prevent redundant TTS requests within short time windows",
            "dependencies": [
              1,
              4
            ],
            "details": "Create RequestDeduplicator with sliding time window (5 seconds). Use content hash for duplicate detection ignoring whitespace differences. Queue duplicate requests to share single API call result. Implement promise-based response sharing for concurrent duplicates. Track deduplication statistics (requests saved, time saved). Add configuration for dedup window size and similarity threshold. Handle edge cases like partial matches.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create performance report generation system",
            "description": "Build comprehensive reporting module for performance metrics visualization and analysis",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implement PerformanceReporter with multiple output formats (JSON, HTML, CSV). Generate reports including: response time histograms, memory usage graphs, cache effectiveness metrics, API call statistics, error rates and types. Add time-based aggregations (hourly, daily summaries). Create performance dashboards with matplotlib/plotly. Export Prometheus-compatible metrics. Include recommendations based on patterns (e.g., 'Consider increasing cache size').",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement performance optimizations",
            "description": "Apply various optimization techniques to improve system performance",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Pre-compile all regex patterns at module load using re.compile(). Implement lazy loading for TTS components (delay SDK import until first use). Add connection pooling for API clients with keep-alive. Use msgpack for faster serialization of cached data. Implement async queue processing for non-blocking operations. Add batch processing for multiple short messages. Optimize audio playback with buffer pre-loading. Profile and optimize hot paths identified by metrics.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Develop Comprehensive Logging System",
        "description": "Create detailed logging for debugging and monitoring TTS operations",
        "details": "Enhance logging in all TTS components using Python logging module. Create log levels: DEBUG (detailed processing), INFO (TTS triggers), WARNING (recoverable errors), ERROR (failures). Add structured logging with context: tool name, text length, voice used, processing time. Implement log rotation to prevent disk usage issues. Create TTS-specific log file at .claude/logs/tts.log.",
        "testStrategy": "Test log output at each level. Verify log rotation works correctly. Test structured logging format. Ensure sensitive data isn't logged. Validate log file permissions and location.",
        "priority": "low",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create Cross-Platform Audio Support",
        "description": "Ensure audio playback works reliably across all supported platforms",
        "details": "Implement platform_audio.py with platform detection and appropriate audio backends. Use pyaudio for cross-platform support with fallbacks: macOS (AVFoundation), Windows (winsound), Linux (ALSA/PulseAudio). Add audio device detection and validation. Implement volume normalization across platforms. Handle audio format conversion if needed. Create audio device fallback chain.",
        "testStrategy": "Test audio playback on macOS, Windows, Linux. Verify device detection works. Test with various audio configurations. Validate volume levels are consistent. Test fallback mechanisms when primary audio fails.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Platform Detection Logic",
            "description": "Create core platform detection system to identify operating system and available audio capabilities",
            "dependencies": [],
            "details": "Develop platform_audio.py base module with platform detection using sys.platform and platform.system(). Create PlatformDetector class that identifies OS (darwin/macOS, win32/Windows, linux), available audio libraries (check for PyAudio, AVFoundation, winsound, ALSA, PulseAudio), and system audio capabilities. Return platform-specific configuration object with preferred and fallback audio backends.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate PyAudio as Primary Backend",
            "description": "Implement PyAudio wrapper as the primary cross-platform audio solution",
            "dependencies": [
              1
            ],
            "details": "Create PyAudioBackend class implementing common audio interface. Handle PyAudio initialization with error recovery, stream creation with configurable parameters (sample rate, channels, chunk size), audio playback with buffer management, and proper cleanup/resource management. Implement format conversion support for various audio formats. Add logging for debugging audio issues.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement macOS AVFoundation Backend",
            "description": "Create native macOS audio implementation using AVFoundation framework",
            "dependencies": [
              1
            ],
            "details": "Develop AVFoundationBackend class using PyObjC bridge to access AVFoundation. Implement AVAudioPlayer wrapper for audio playback, volume control with normalization, audio session configuration for background playback, and device routing support. Handle macOS-specific audio formats (Core Audio). Create fallback to PyAudio if AVFoundation unavailable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Windows winsound Integration",
            "description": "Create Windows-specific audio backend using winsound module",
            "dependencies": [
              1
            ],
            "details": "Build WinsoundBackend class wrapping Windows winsound module. Implement basic WAV playback support, asynchronous playback options, volume control through Windows Audio Session API, and format conversion from MP3 to WAV if needed. Handle Windows-specific limitations (WAV-only support) with automatic format conversion. Add Windows Media Foundation as advanced option.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Linux ALSA/PulseAudio Support",
            "description": "Create Linux audio backend supporting both ALSA and PulseAudio",
            "dependencies": [
              1
            ],
            "details": "Develop LinuxAudioBackend class with dual support for ALSA (via pyalsaaudio) and PulseAudio (via pulsectl or direct). Implement audio device enumeration, playback with proper buffer management, volume control through system mixer, and format handling. Create detection logic to prefer PulseAudio on modern systems, fallback to ALSA on older systems.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build Audio Device Detection and Validation",
            "description": "Implement comprehensive audio device detection across all platforms",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Create AudioDeviceManager class to enumerate available audio output devices, validate device capabilities (sample rates, channels), detect default system audio device, and monitor device changes (plug/unplug). Implement device testing with silent audio probe, capability matrix building, and device preference management. Store device configuration for quick startup.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Volume Normalization System",
            "description": "Create cross-platform volume normalization to ensure consistent audio levels",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Build VolumeNormalizer class implementing peak normalization algorithm, RMS-based loudness detection, platform-specific volume scaling factors, and configurable target loudness levels. Handle different volume APIs across platforms, implement soft limiting to prevent clipping, and create volume calibration routine. Store normalization profiles per platform.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create Audio Format Conversion Handler",
            "description": "Implement audio format conversion to handle various input formats",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Develop AudioFormatConverter using pydub or similar library. Support conversion between MP3, WAV, OGG, and platform-specific formats. Implement sample rate conversion (8kHz-48kHz), bit depth conversion (8-32 bit), channel conversion (mono/stereo), and codec selection. Cache converted files for performance. Handle streaming conversion for large files.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Implement Fallback Chain Mechanism",
            "description": "Create robust fallback system to ensure audio always plays",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Build FallbackAudioManager orchestrating all backends with priority chain: PyAudio → Platform-specific → System command. Implement health checking for each backend, automatic failover on errors, backend recovery attempts, and fallback to system commands (afplay, aplay, powershell). Add logging of fallback decisions and performance metrics. Create user notification for degraded audio modes.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Advanced Configuration Features",
        "description": "Add advanced configuration options for power users",
        "details": "Extend configuration with advanced features: per-tool voice settings, custom tool messages, pronunciation dictionary for technical terms, quiet hours scheduling, keyboard shortcuts for quick toggle. Add configuration validation UI using simple CLI tool. Implement configuration export/import. Create configuration presets (minimal, standard, verbose).",
        "testStrategy": "Test each advanced configuration option. Verify per-tool settings override defaults. Test configuration validation catches errors. Validate import/export functionality. Test preset application and switching.",
        "priority": "low",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design per-tool voice settings architecture",
            "description": "Create data structure and schema for per-tool voice configurations",
            "dependencies": [],
            "details": "Design a flexible configuration structure that supports individual tool voice settings. Create schema for voice_settings dictionary with tool names as keys and voice configuration objects as values. Support inheritance from default settings with tool-specific overrides for voice_id, speed, volume, and enabled state.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement custom tool message configuration",
            "description": "Build system for customizing tool-specific TTS messages",
            "dependencies": [
              1
            ],
            "details": "Create custom_messages.py module with CustomMessageManager class. Implement template system for tool messages with variable substitution. Support message templates like '{tool_name} completed with exit code {exit_code}'. Add configuration for success/failure messages per tool type. Include message preview functionality.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create pronunciation dictionary implementation",
            "description": "Build technical term pronunciation system",
            "dependencies": [],
            "details": "Implement pronunciation_dict.py with PronunciationDictionary class. Support phonetic replacements for technical terms (e.g., 'npm' -> 'N P M', 'git' -> 'git', 'CLI' -> 'command line interface'). Add regex-based pattern matching for common patterns. Support user-defined pronunciations in settings.json. Include IPA phonetic notation support.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement quiet hours scheduling system",
            "description": "Create time-based TTS control system",
            "dependencies": [],
            "details": "Build quiet_hours.py with QuietHoursManager class. Implement time range parsing (e.g., '22:00-08:00'). Support multiple quiet periods and timezone handling. Add override capability for urgent messages. Create is_quiet_time() check method. Support weekday/weekend differentiation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add keyboard shortcut handling",
            "description": "Implement cross-platform keyboard shortcuts for TTS control",
            "dependencies": [],
            "details": "Create keyboard_shortcuts.py with platform-specific implementations. Support shortcuts for: toggle TTS on/off, replay last message, skip current speech, adjust volume/speed. Use pynput for cross-platform support. Add configurable key bindings in settings.json. Implement shortcut conflict detection.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build configuration validation CLI tool",
            "description": "Create command-line tool for configuration validation",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement validate_config.py CLI tool using argparse. Add schema validation for all TTS settings. Check for invalid tool names, voice IDs, and parameter ranges. Provide helpful error messages with fix suggestions. Support --fix flag for automatic correction of common issues. Add --verbose mode for detailed validation output.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement import/export functionality",
            "description": "Create configuration backup and sharing system",
            "dependencies": [
              6
            ],
            "details": "Build config_io.py with import/export capabilities. Support JSON and YAML formats for configuration files. Implement version checking and migration for imported configs. Add encryption option for sensitive settings. Create merge strategies for partial imports. Support configuration diffing between files.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create configuration preset system",
            "description": "Build preset management for common configuration profiles",
            "dependencies": [
              1,
              2,
              3,
              4,
              7
            ],
            "details": "Implement presets.py with PresetManager class. Create built-in presets: minimal (essential confirmations only), standard (balanced verbosity), verbose (all outputs), developer (technical focus), accessibility (maximum clarity). Support custom preset creation and sharing. Add preset switching via CLI command. Include preset preview functionality.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Build Integration Test Suite",
        "description": "Create comprehensive integration tests for the complete TTS system",
        "details": "Develop integration test suite covering end-to-end scenarios. Test complete flow: command execution → hook trigger → text processing → TTS generation → audio playback. Create test scenarios for each tool type. Add performance regression tests. Implement mock ElevenLabs API for CI/CD testing. Create test fixtures for various command outputs.",
        "testStrategy": "Run full integration tests simulating real command executions. Test with various Claude Code tools. Verify TTS triggers appropriately. Measure end-to-end performance. Test error scenarios in integration context.",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up pytest framework and test structure",
            "description": "Initialize pytest framework with proper directory structure and configuration for integration testing",
            "dependencies": [],
            "details": "Create tests/integration/ directory structure. Set up pytest.ini with test discovery patterns and markers for integration tests. Configure pytest-asyncio for async test support. Add pytest-mock for mocking capabilities. Create conftest.py with shared fixtures for test setup/teardown. Set up test environment variables and configuration loading.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement mock ElevenLabs API server",
            "description": "Create a mock server that simulates ElevenLabs API responses for testing without real API calls",
            "dependencies": [
              1
            ],
            "details": "Build mock_elevenlabs.py using responses or pytest-httpserver. Mock endpoints: /v1/text-to-speech/{voice_id}, /v1/voices, /v1/user. Return mock audio data (silence or test tone). Simulate rate limiting, API errors, and network failures. Support all voice IDs used in production. Create fixture for easy mock activation in tests.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create end-to-end test scenarios",
            "description": "Develop comprehensive test cases covering the complete TTS workflow from command to audio",
            "dependencies": [
              1,
              2
            ],
            "details": "Test scenarios: successful bash command → TTS → audio playback, git commit → status message → TTS, file write → confirmation → TTS, error handling flow with retries. Create test_e2e_workflows.py with parameterized tests for different tools. Mock Claude Code tool outputs. Verify complete flow including hook triggers and audio generation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement tool-specific test cases",
            "description": "Create targeted tests for each tool type's filtering and TTS behavior",
            "dependencies": [
              1,
              2
            ],
            "details": "Create test files: test_bash_integration.py (exit codes, command outputs), test_git_integration.py (status, commit, push), test_file_operations.py (read/write confirmations), test_search_tools.py (grep/ls exclusions). Test filter logic for each tool type. Verify appropriate messages are generated. Test edge cases and malformed outputs.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build performance regression test suite",
            "description": "Create tests to monitor and prevent performance degradation in TTS processing",
            "dependencies": [
              1,
              3
            ],
            "details": "Implement test_performance.py with benchmarks for: text processing speed, API response times, audio generation latency, end-to-end execution time. Use pytest-benchmark for performance tracking. Set acceptable thresholds for each metric. Create performance fixtures with large text samples. Test concurrent TTS requests handling.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create comprehensive test fixtures",
            "description": "Develop reusable test data and fixtures for various command outputs and scenarios",
            "dependencies": [
              1
            ],
            "details": "Create fixtures/: sample_outputs.json with real tool outputs, audio_samples/ with test audio files, config_samples/ with various configurations. Build fixture factories for: tool outputs with different formats, error scenarios, edge cases (empty output, very long text). Create parameterized fixtures for voice selection testing.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Configure CI/CD pipeline integration",
            "description": "Set up automated testing in CI/CD pipeline with proper test reporting",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create .github/workflows/test-tts.yml for GitHub Actions. Configure test matrix for multiple Python versions and OS. Set up test result reporting with pytest-html. Add code coverage with pytest-cov and coverage thresholds. Configure artifact uploads for test logs and reports. Add integration test stage that uses mock API. Set up test failure notifications.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Create User Documentation and Setup Guide",
        "description": "Develop comprehensive documentation for installation and usage",
        "details": "Write detailed README.md with: installation instructions using UV, ElevenLabs API key setup, configuration guide with examples, troubleshooting section, FAQ. Create docs/: CONFIGURATION.md (all settings explained), TROUBLESHOOTING.md (common issues), CONTRIBUTING.md (development guide). Add inline code documentation. Create quick start video tutorial script.",
        "testStrategy": "Test installation instructions on fresh environment. Verify all configuration examples work. Test troubleshooting steps resolve issues. Have new user follow documentation to validate completeness.",
        "priority": "low",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Performance Optimization and Final Testing",
        "description": "Optimize system performance and conduct final validation testing",
        "details": "Profile entire system to identify bottlenecks. Optimize: text processing with pre-compiled regex, API call batching where possible, memory usage with object pooling, startup time with lazy imports. Conduct load testing with rapid command execution. Validate <2 second TTS response time. Ensure <50MB memory overhead. Test with 1000+ command executions for stability.",
        "testStrategy": "Benchmark before/after optimization. Run extended stress tests. Monitor resource usage over time. Test with various workloads. Validate all success metrics are met. Conduct user acceptance testing.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "System Profiling and Bottleneck Identification",
            "description": "Profile the entire TTS system to identify performance bottlenecks and establish baseline metrics",
            "dependencies": [],
            "details": "Use Python profiling tools (cProfile, line_profiler) to analyze performance_monitor.py, error_handler.py, config_manager.py, and all TTS components. Identify slow functions, memory hotspots, and API call patterns. Create detailed performance report with bottleneck analysis. Measure baseline metrics: TTS response time, memory usage, startup time, API call frequency. Document findings for optimization targets.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Text Processing Optimization",
            "description": "Optimize text processing operations using pre-compiled regex patterns and efficient string operations",
            "dependencies": [
              1
            ],
            "details": "Replace dynamic regex compilation with pre-compiled patterns in text parsing modules. Optimize text truncation and splitting algorithms. Implement string interning for repeated phrases. Use str.join() instead of concatenation loops. Cache processed text results for duplicate inputs. Optimize Unicode handling and normalization. Target 50% reduction in text processing time.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "API Call Batching Implementation",
            "description": "Implement intelligent batching for TTS API calls to reduce network overhead",
            "dependencies": [
              1
            ],
            "details": "Create BatchProcessor class to queue and batch API requests. Implement adaptive batching with configurable time window (100-500ms). Add request coalescing for identical texts within batch window. Implement priority queue for urgent requests. Add batch size limits based on API constraints. Create fallback for single requests when batching not beneficial. Monitor batch efficiency metrics.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Memory Optimization with Object Pooling",
            "description": "Implement object pooling and memory optimization strategies to reduce memory overhead",
            "dependencies": [
              1
            ],
            "details": "Create ObjectPool class for reusable audio buffers and request objects. Implement connection pooling for API clients. Add weak references for cache management. Optimize data structures using slots for frequently created objects. Implement garbage collection tuning. Add memory profiling hooks. Target <50MB memory overhead under load. Monitor and prevent memory leaks.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Startup Time Optimization",
            "description": "Optimize system startup time through lazy loading and deferred initialization",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement lazy imports for TTS components using importlib. Defer API client initialization until first use. Create lightweight proxy objects for heavy dependencies. Optimize configuration loading with caching. Parallelize independent initialization tasks. Remove unnecessary startup validations. Implement progress indicators for long operations. Target <1 second cold start time.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Load Testing Implementation",
            "description": "Develop and execute comprehensive load testing scenarios for the TTS system",
            "dependencies": [
              5
            ],
            "details": "Create load_test.py with scenarios: rapid sequential commands, concurrent TTS requests, mixed workloads, sustained load (1000+ commands). Implement metrics collection during tests: response times, queue lengths, memory usage, error rates. Test edge cases: maximum text length, special characters, multiple voices. Simulate network failures and recovery. Generate performance reports with graphs. Validate <2 second response time under load.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Resource Monitoring Validation",
            "description": "Validate resource usage metrics and ensure system meets performance targets",
            "dependencies": [
              6
            ],
            "details": "Implement continuous resource monitoring during extended test runs. Validate memory usage stays under 50MB overhead. Monitor CPU usage patterns and spikes. Check file descriptor and thread usage. Verify no resource leaks over 24-hour test. Monitor disk I/O for log files and caches. Validate network bandwidth usage. Create automated alerts for threshold violations. Generate resource usage dashboards.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "User Acceptance Testing Coordination",
            "description": "Coordinate and execute user acceptance testing to validate real-world performance",
            "dependencies": [
              7
            ],
            "details": "Create UAT test scenarios covering typical user workflows. Recruit test users with diverse usage patterns. Provide testing guidelines and feedback forms. Monitor real-world performance metrics during UAT. Collect qualitative feedback on responsiveness and reliability. Test on various hardware configurations. Validate TTS quality and timing meet expectations. Document and prioritize any issues found. Create final performance report with recommendations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-15T19:44:16.184Z",
      "updated": "2025-07-15T20:35:09.973Z",
      "description": "Tasks for master context"
    }
  }
}